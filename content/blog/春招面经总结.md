---
title: 春招面经总结
date: 2019-04-07 00:34:40
tags: 面经
---



这几个月来面了很多次试，从去年十二月开始断断续续地投递简历到今年三月正式进入大厂的面试流程，如今我的春招实习之路算是结束了，期间面过大小厂都面过不少，拿到 offer 的有腾讯、百度、滴滴、即刻、英伟达、日志易，现在想把这段面试遇到的题目分类记录下来并形成自己的笔记以供秋招包括以后可能的面试参考。

### HTML

- DOCTYPE
- iframe
  - 主要是它的优缺点
  - 现在基本由 ajax 替代了
- 语义化
  - 块级元素：div、form、h...、hr、ul、table
  - 行内元素：span、a、input、label、textarea
- 新特性
  - 区块和段落元素
  - Web Workers
  - History API
  - contentEditable 属性
  - Canvas、SVG
  - 拖放、定位

### CSS

- 盒模型
  - box-sizing 设为 border-box: IE 盒模型宽度包括 border、padding
- BFC
- 垂直居中实现
- 布局实现

### JS

- 基本类型、引用类型
- 原型
- this
- EventLoop
- forEach 和 map 有什么区别
- 多个标签页之间通信
- 柯里化（在线编程实现）
- 设计模式

### 框架

- jQuery vs Vue vs React
- 路由

- Vue
  - 子组件怎么调用父组件的方法（组件通信）
  - 生命周期
  - v-show、v-if
  - 响应式原理、computed 实现
- React
  - diff 算法
  - setState
  - 事件机制
  - 直出|同构（服务端渲染）

### 浏览器

- 跨域
  - 原理
  - 如何解决（JSONP、CORS）
- 存储
  - cookie
  - localStorage
  - sessionStorage
- 渲染原理
  - 过程
  - 阻塞渲染（重绘与回流）
- 安全
  - XSS（分类、防范）
  - CSRF（原理、防御）

### 性能优化

- 首屏渲染
- Webpack 打包
- 懒加载

### Node

- require 同步还是异步、循环引用问题

### 网络

- HTTP、HTTP/2、HTTPS

### 算法

- 斐波那契数列（剑指 offer）
  - 递归、非递归、动态规划
  - 利用数学公式
- 最大子段序列和
- 求质数
  - 循环相除到一半即可
  - 利用数学公式
- 两个子节点找最近公共祖先（剑指 offer）
- 反转一个单链表（剑指 offer）
- 排序（快排、归并、堆排）
- 从 10000 个数中找到最大的 10 个数如何操作（TopK 问题）
- 背包问题

### 在线 coding

- 计算千位分隔符

```js
function numFormat(num) {
  if (!num) return ''
  if (num.toString().indexOf('.') !== -1) {
    return num.toLocaleString()
  } else {
    return num.toString().replace(/\B(?=(\d{3})+\b)/g, ',')
  }
}
```

- 计算时分夹角

```js
function getAngle (time) {
    const [hour, minutes] = time.split(':');
    const hourTri = Number(hour) * 30;
    const minTri  = Number(minutes) * 6;
    const hourPro = Number(minutes) / 60 * 30;
    const angle = Math.abs(hourTri + hourPro - minTri);
    return angle > 180 ? 360 - angle : angle;
}
```

- 给定一个 m*n 的字符串，以逆时针螺旋顺序输出为一个二维矩阵（剑指 offer 变形题）

```js
// 输入一串字符，顺时针生成一个二维矩阵
// 用一个循环来生成矩阵，每次生成一个圈

let index = 0  // 字符串下标
let res = []  // 返回的矩阵数组

const printStrToMatrix = (str, m, n) => {
  if (str.length === 0 || m <= 0 || n <= 0)　return

  let start = 0
  for (let i = 0; i < m; i++) res[i] = []
  while (m > start * 2 && n > start * 2) {
    genMatrixInCircle(str, m, n, start)
    ++start
  } 

  return res
}

const genMatrixInCircle = (str, m, n, start) => {
  let endX = m - 1 - start
  let endY = n - 1 - start

  // 从左到右赋值一行
  for (let i = start; i <= endX; ++i) {
    res[start][i] = str[index++]
  }
  
  // 从上到下赋值一列
  if (start < endY) {
    for (let i = start + 1; i <= endY; ++i) {
      res[i][endX] = str[index++]
    }
  }

  // 从右到左赋值一行
  if (start < endX && start < endY) {
    for (let i = endX - 1; i >= start; --i) {
      res[endY][i] = str[index++]
    }
  }

  // 从下到上赋值一列
  if (start < endX && start < endY - 1) {
    for (let i = endY - 1; i>= start + 1; --i) {
      res[i][start] = str[index++]
    }
  }
}
```

- 输入：[‘2018-02-03’, ‘2018-01-25’, ‘2018-02-01’];输出：[‘2018-01-25’, ‘2018-02-01’, ‘2018-02-03’]

```js
function dateSort(date) {
  return date.sort((a, b) => new Date(a) - new Date(b))
}
```

```js
function Hero (name) {
	// 实现代码
    this.name = name
    console.log(`英雄${this.name}诞生`)
    this.kill = function (enemyNum) {
    	console.log(`${this.name}击杀了${enemyNum}个敌人`)
    	return this
    }
    this.blood = function (attackNum) {
    	console.log(`${this.name}造成了${attackNum}点伤害`)
    	return this
    }
}
var hero = new Hero('哈哈');
hero.kill('2').blood('20');

输出：
英雄哈哈诞生
哈哈击杀了2个敌人；
哈哈造成了20点伤害；
```

- 计算网页有多少种 DOM 元素

```js
let all2 =  document.querySelectorAll('*');
let strAll2 = new Set();
for(let i = 0,length = all2.length; i < length;i++){
	strAll2.add(all2[i].nodeName.toLowerCase());
}
console.log(strAll2.size);
```

```js
function walk (el, action) {
  if (el) {
    action(el)
    walk(el.firstElementChild, action)
    walk(el.nextElementSibling, action)
  }
}

function compute () {
  const set = new Set()
  walk(document.documentElement, el => set.add(el.nodeName))
  return set.size
}
```

- 实现一个快速排序
- 实现一个事件总线系统
  - 具备 on 方法绑定事件
  - 具备 off 方法解绑事件

```js
class EventEmitter {
  constructor () {
    this._events = {}
  }

  on(eventName, callback) {
    let callbacks = this._events[eventName] || []
    callbacks.push(callback)
    this._events[eventName] = callbacks
  }
  off(eventName) {
    delete this._events[eventName]
  }
  emit(eventName, ...arg) {
    let callbacks = this._events[eventName]
    
    if (!callbacks || callbacks.length === 0) {
      throw new Error('You should register listener for event ' + eventName)
    }
    
    callbacks.forEach(fn => fn.apply(this, arg))
  }
}
```

- 二分查找
- 输入两个整数 n 和 m，从数列1，2，3…n 中随意取几个数,使其和等于 m ,要求将其中所有的可能组合列出来

```js
const arr = []
const sumOfKNum = (m, n) => {
  if (n <= 0 || m <= 0) return

  if (m === n) {
    let flag = true
    for (let i = 0, len = arr.length; i < len; i++) {
      console.log(arr[i] + " " + n)
      flag = false
    }
    if (flag) console.log(n)
  }
  arr.unshift(n)
  sumOfKNum(m - n, n - 1)
  arr.shift()
  sumOfKNum(m, n - 1)
}
```



综合以上的面试题也可以感觉到，掌握好网上大多数的面经在面试准备上基本就没什么问题了，规范的流程一般也是前一二面更多注重基础算法等等，后面就是看自身的沉淀了，这个就需要实际项目中有足够的技术深度学习，实践过对口的业务场景，平时多思考多总结，把自己的学习能力与潜力展示出来，大厂需要的就是这样的人。

同时对于实际的面试周期，也要有足够的耐心和毅力，面试本身是一个很耗心力的过程，一般做好准备再去应战，选择好适合自己的部门也是很必要的（也要避免扎堆投放流程被卡死/(ㄒoㄒ)/~~），对于最后能不能拿到 offer 也有一定的运气成分，但我们能把握的就是扎实地提升自己，最后写一句之前看到的很有道理的话吧：大多数人总是高估自己一天能做的事，却低估自己一年能做的事。共勉！！！