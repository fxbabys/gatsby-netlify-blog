---
title: 面向对象与原型
date: 2017-11-23 18:22:47
tags: javascript
---

这里会先把之前已经写好的总结陆续放上来，主要也是有一个时间顺序记录自己的学习过程（(#^.^#)）

# 面向对象与原型

### 一.创建对象：

#### 1.最基本的创建一个对象并添加属性和方法

![](https://ooo.0o0.ooo/2017/07/02/5958f4ccc2af4.png)

缺点：每创建一个类似对象，都会产生大量代码

解决：工厂模式解决实例化对象产生大量重复代码，即设计一个实例化的函数


#### 2.工厂模式：

![](https://ooo.0o0.ooo/2017/07/02/5958f59831804.png)

新问题：无法区别实例的来源对象

解决：用构造函数来创建特定的对象


#### 3.构造函数

![](https://ooo.0o0.ooo/2017/07/02/5958f60585ac4.png)

重复实例化和对象识别的问题都得到解决

规范：
1.函数名和实例化名相同并且首字母大写（有助于区分构造函数和普通函数）

2.必须用new运算符创建对象（与普通函数的区别）

与工厂模式的区别：
1.构造函数没有显式地创建对象

2.直接把属性方法赋给this对象

3.没有return语句

小问题：在对run方法的引用上每次实例化的地址都不同，即alert(person1.run == person2.run)的结果是false


### 二.原型

创建的每个函数都有一个prototype属性（对象）。包含可以由特定类型的所有实例共享的属性和方法

![](https://ooo.0o0.ooo/2017/07/02/5958f79adfc73.png)

#### 1.构造函数与原型模式的声明方式：

![](https://ooo.0o0.ooo/2017/07/02/5958f7ee77a67.png)

![](https://ooo.0o0.ooo/2017/07/02/5958f804640eb.png)

通过两种方式的对比可以明白为什么它们在对方法的引用地址上会有区别

#### 2.原型模式的执行流程：

构造函数实例里有属性或方法的话就返回，没有就去它的原型对象中找


#### 对属性是在构造函数的实例里还是原型里的判断：

    hasOwnProperty()--->实例有返回true

    in操作符        --->只要存在就返回true

                    --->两种方法结合判断原型中是否存在属性

#### 3.原型模式创建对象的缺点：共享

-----如果某次实例化时改变了原型中的属性，则会影响到之后的实例化对象

-----如果有传入参数的话，之后的实例化对象属性会覆盖掉之前的，无法独立

#### 即用相同原型创建的对象访问原型中的属性时，访问的都是同一个对象

解决：构造函数+原型模式的组合模式：

- 构造函数适合封装属性
- 原型模式适合封装方法


#### 组合模式：

![](https://ooo.0o0.ooo/2017/07/02/5958fa40b9a60.png)

解决了传参和共享的难题，进一步的优化是把构造函数和原型封装到一起

#### 动态原型模式：

![](https://ooo.0o0.ooo/2017/07/02/5958fa8190515.png)

以上两种是JS创建对象时使用较多的方式，优先考虑动态原型模式

#### 4.补充：

寄生构造函数：工厂模式+构造函数模式

--->需要创建一个具有额外方法的引用类型

![](https://ooo.0o0.ooo/2017/07/02/5958fb60c3f0b.png)

稳妥构造函数：

--->构造函数中不用this,外部实例化函数时不用new

![](https://ooo.0o0.ooo/2017/07/02/5958fb7573eb1.png)


### 三.继承

#### 1.原型链
正统面向对象语言实现继承的方式：接口实现和继承

ECMAScript只支持继承，实现的方式是依靠**原型链**

实质：通过原型让一个引用类型继承另一个引用类型的属性和方法

![](https://ooo.0o0.ooo/2017/07/03/59591a80318cb.png)

![](https://ooo.0o0.ooo/2017/07/03/59591c573d9dc.png)

被继承的函数称为超类型（父类、基类）;继承的函数称为子类型（子类、派生类）

**继承存在的问题：**
- 字面量重写原型会中断关系
- 子类型无法给超类型传递参数

#### 2.借用构造函数（对象冒充）
--->解决引用共享和不能给超类型传参的问题

![](https://ooo.0o0.ooo/2017/07/03/595993685b8a7.png)

新问题：没有原型，无法复用

#### 3.组合继承（最常用）
--->通过原型链继承原型的属性方法

--->通过借用构造函数继承实例的属性

--->既实现了函数复用，又保证每个实例的独立性

![](https://ooo.0o0.ooo/2017/07/03/595990a376a5b.png)

#### 4.原型式继承
--->借助原型并基于已有的对象创建新对象，不用再创建自定义类型

![](https://ooo.0o0.ooo/2017/07/03/59599952b8aaf.png)

#### 5.寄生式继承（原型式+工厂模式）
--->为了封装创建对象的过程

![](https://ooo.0o0.ooo/2017/07/03/59599acd1fc6b.png)

#### 6.寄生组合式继承
--->处理组合式继承的问题：超类型在使用过程中被调用了两次：

- 创建子类型时
- 在子类型构造函数内部

![](https://ooo.0o0.ooo/2017/07/03/59599c8f278a0.png)

通过原型链的混成形式调用方法，解决了两次调用的问题


### 总结：

1.创建对象：

工厂模式：用简单的函数创建对象，添加属性方法然后返回它

构造函数模式：可以创建特定的对象，但是它的成员包括函数都不能复用

原型模式：利用函数的prototype属性来指定应该共享的方法和属性

组合模式：利用构造函数定义实例属性，利用原型定义共享方法

2.继承：

原型链继承：通过原型让一个引用类型继承另一个引用类型的属性和方法

借用构造函数（对象冒充）：解决引用共享和超类型不能传参的问题

组合继承：通过原型链继承原型的属性方法，通过借用构造函数继承实例的属性，最常用，但有多次调用超类型构造函数导致的低效率问题

原型式继承：在已有对象上借助原型创建新对象，新对象可以进一步添加属性方法

寄生式继承：封装了创建对象的过程，基于这个可以进一步增强对象

寄生组合式继承：通过原型链的混成形式调用方法，避免多次调用超类型构造函数，基于类型继承的最有效方式